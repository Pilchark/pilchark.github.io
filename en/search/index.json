[{"content":"leetcode No.135 There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nEach child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nInput: ratings = [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2:\nInput: ratings = [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.\nForthright Solution 1 2 3 4 5 6 7 8 9 10 def candy(ratings: list[int]): length = len(ratings) res = [1] * length for i in range(1,length): if ratings[i] \u0026gt; ratings[i-1]: res[i] += 1 for i in range(length-2,-1,-1): if ratings[i] \u0026gt; ratings[i+1]: res[i] += 1 return sum(res) wrong answer [1,3,2,2,1] answer: 8 expect: 7\nReason: while doing the right-to-left traversal, if left already \u0026gt; right, then we don\u0026rsquo;t need always change left value to right + 1\n1 2 3 4 5 6 7 8 9 10 11 12 def candy(ratings: list[int]): length = len(ratings) res = [1] * length for i in range(1,length): if ratings[i] \u0026gt; ratings[i-1]: res[i] += 1 print(res) for i in range(length-1, 0,-1): if ratings[i] \u0026lt; ratings[i-1]: res[i-1] = max(res[i-1], res[i]+1) print(res) return sum(res) wrong: candy([1,2,87,87,87,2,1]) output: [1, 2, 2, 1, 3, 2, 1] 12 expect: 13\nReason: while traversal left to right, if rate right \u0026gt; left, then res right = res[left]+1\n1 2 3 4 5 6 7 8 9 10 11 12 def candy(ratings: list[int]): length = len(ratings) res = [1] * length for i in range(1,length): if ratings[i] \u0026gt; ratings[i-1]: res[i] = res[i-1]+1 print(res) for i in range(length-1, 0,-1): if ratings[i] \u0026lt; ratings[i-1]: res[i-1] = max(res[i-1], res[i]+1) print(res) return sum(res) Summary Greedy strategies with comparative relationships do not necessarily require sorting.\n","date":"2025-04-03T00:00:00Z","permalink":"https://pilchark.github.io/en/p/candy/","title":"Candy"},{"content":"Egg drop. Suppose that you have an n-story building (with floors 1 through m) and plenty 1 of eggs. An egg breaks if itis dropped from floor T or higher and does not break otherwise. Your goalis to devise a strategy to determine the value of T given the following limitations on the number of eggs and tosses\nVersion 0: 1 egg， ≤ T tosses. Version 1:~ 1lg n eggs and ~1 lg n tosses. Version 2: ~lg T eggs and ~ 2lg T tosses. Version 3: 2 eggs and 2sqrt(n) tosses. Version 4: 2 eggs and ≤ csqrt(T) tosses for some fixed constant c.\nEgg Drop Problem Solutions This is a classic \u0026ldquo;egg dropping\u0026rdquo; problem. The problem is described as: There is an n-floor building (floor numbers from 1 to n) and several eggs. There is a critical floor T. Eggs dropped from floors T or higher will break, while eggs dropped from floors below T will not break. The goal is to find a strategy to determine the threshold value T while meeting the limitations of different versions on the number of eggs and the number of times eggs are thrown.\nLet\u0026rsquo;s analyze each version of the egg drop problem to determine strategies for finding the threshold floor T.\nVersion 0: 1 egg, ≤ T tosses Strategy: Linear search starting from floor 1.\nStart from floor 1 and move up one floor at a time Try floor 1, then floor 2, and so on until the egg breaks If the egg breaks at floor k, then T = k If we reach floor n without breaking, then T \u0026gt; n Analysis:\nWorst case: T tosses (when T = n) This is optimal with 1 egg since we need to check every floor below T Version 1: ~lg n eggs and ~lg n tosses Strategy: Binary search\nFirst try floor n/2 If the egg breaks, search the lower half (floors 1 to n/2-1) If the egg doesn\u0026rsquo;t break, search the upper half (floors n/2+1 to n) Continue this binary division until T is found Analysis:\nEach toss eliminates half of the remaining floors Requires lg n tosses in the worst case Requires lg n eggs in the worst case (if we\u0026rsquo;re unlucky and break an egg at each step) Version 2: ~lg T eggs and ~2lg T tosses Strategy: Modified binary search that\u0026rsquo;s more careful near T\nFirst use binary search to find a power of 2, say 2^k, such that the egg breaks at 2^k but not at 2^(k-1) This takes about lg T tosses and lg T eggs in the worst case Then binary search between 2^(k-1) and 2^k to find T exactly This takes another lg T tosses Analysis:\nTotal tosses: ~2lg T Total eggs needed: ~lg T Version 3: 2 eggs and 2*sqrt(n) tosses Strategy: Two-phase approach with uniform jumps\nWith first egg, check floors sqrt(n), 2sqrt(n), 3sqrt(n), etc. When the egg breaks at k*sqrt(n), use the second egg to check floors linearly from (k-1)sqrt(n)+1 to ksqrt(n)-1 Analysis:\nFirst phase takes at most sqrt(n) tosses Second phase takes at most sqrt(n) tosses Total tosses: ≤ 2*sqrt(n) Version 4: 2 eggs and ≤ c*sqrt(T) tosses Strategy: Decreasing step sizes approach\nStart with steps of size x, then x-1, then x-2, and so on For this to cover n floors: x + (x-1) + (x-2) + \u0026hellip; + 1 ≥ n This sum equals x(x+1)/2, so we need x(x+1)/2 ≥ n Solving for x, we get x ≈ sqrt(2n) Use first egg to check floors x, x+(x-1), x+(x-1)+(x-2), etc. When it breaks, use second egg for linear search in the last interval Analysis:\nIf T is the threshold, the worst case happens when the first egg breaks at last possible drop This gives us approximately sqrt(2T) tosses in total So c ≈ sqrt(2) in this version Each of these strategies is optimal for the given constraints on eggs and tosses.\n","date":"2025-04-02T00:00:00Z","permalink":"https://pilchark.github.io/en/p/egg-drop-problem/","title":"Egg Drop Problem"},{"content":"leetcode No.455 Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] \u0026gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nForthright Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution: def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: children = sorted(g) cookies = sorted(s) index_c = len(children)-1 res = 0 for c in cookies[::-1]: print(c) while index_c \u0026gt;= 0: print(children[index_c]) if children[index_c] \u0026gt; c: index_c -=1 else: res +=1 index_c -=1 break return res failed situation: g = [1,2,3], s=[3]\nFix:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: children = sorted(g) cookies = sorted(s) res = 0 child = len(children)-1 cookie = len(cookies)-1 while child \u0026gt;= 0 and cookie\u0026gt;=0: if cookies[cookie] \u0026gt;= children[child]: res += 1 cookie-=1 child-=1 else: child-=1 return res Research ","date":"2025-04-01T00:00:00Z","permalink":"https://pilchark.github.io/en/p/assign-cookies/","title":"Assign Cookies"},{"content":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1: Input: n = 3 Output: [\u0026quot;((()))\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;(())()\u0026quot;,\u0026quot;()(())\u0026quot;,\u0026quot;()()()\u0026quot;] Example 2: Input: n = 1 Output: [\u0026quot;()\u0026quot;]\n1. Forthright Solution ideas: for each exists composition, eg. when n = 2, all availble strings are [\u0026quot;()()\u0026quot;, \u0026ldquo;(())\u0026rdquo;] There are 5 position to insert a new bracket, index from 0 - 5.\n[\u0026quot;()(())\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;((()))\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;(())()\u0026quot;], \u0026ldquo;()(())\u0026rdquo;,\u0026quot;(()())\u0026quot;,\u0026quot;((()))\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;(())()\u0026quot; finally remove the duplicate strings we will get the answer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: # check combine def process(sub_comb): res = {} for item in sub_comb: for index in range(len(item)+1): if index == 0: temp = (\u0026#34;()\u0026#34;+ item) elif index == len(item): temp = (item + \u0026#34;()\u0026#34;) else: temp = (item[0:index] + \u0026#34;()\u0026#34; + item[index:]) if temp not in res: res[temp] = 1 return list(res.keys()) if n == 1: return [\u0026#34;()\u0026#34;] sub_comb = self.generateParenthesis(n-1) return process(sub_comb) Research Rules for Valid Parentheses: At any point, the number of closing parentheses cannot exceed the number of opening ones. The total number of opening parentheses cannot exceed n. The total number of closing parentheses cannot exceed n. Code Solution with Backtracking 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def generateParenthesis(n): \u0026#34;\u0026#34;\u0026#34; Generate all combinations of well-formed parentheses given n pairs. Args: n: Number of pairs of parentheses Returns: List of all valid combinations \u0026#34;\u0026#34;\u0026#34; result = [] def backtrack(s, open_count, close_count): \u0026#34;\u0026#34;\u0026#34; Recursive backtracking function to build valid parentheses strings. Args: s: Current string being built open_count: Number of opening parentheses used so far close_count: Number of closing parentheses used so far \u0026#34;\u0026#34;\u0026#34; # Base case: if we\u0026#39;ve used all n pairs, we have a complete valid combination if len(s) == 2 * n: result.append(s) return # We can add an opening parenthesis if we haven\u0026#39;t used all n if open_count \u0026lt; n: backtrack(s + \u0026#34;(\u0026#34;, open_count + 1, close_count) # We can add a closing parenthesis if it doesn\u0026#39;t exceed opening count # This ensures validity - we never close more than we\u0026#39;ve opened if close_count \u0026lt; open_count: backtrack(s + \u0026#34;)\u0026#34;, open_count, close_count + 1) # Start backtracking with empty string and no parentheses used yet backtrack(\u0026#34;\u0026#34;, 0, 0) return result Time and Space Complexity Time Complexity: O(4^n / √n) - This is the nth Catalan number, which is the number of valid combinations. Space Complexity: O(n) for the recursion stack, not counting the output which is O(4^n / √n) * n. Key Insights We maintain validity by adding a closing parenthesis only if there are more opening ones. The backtracking approach builds all valid combinations systematically. The state is tracked by counting opening and closing parentheses used so far. This solution ensures we generate all possible valid combinations without duplicates.\n","date":"2025-03-26T00:00:00Z","permalink":"https://pilchark.github.io/en/p/generate-parentheses/","title":"Generate Parentheses"},{"content":"Health The foremost consumption, which we can better call an investment, I think it\u0026rsquo;s health. The health investment includes mental health and physical health.\nI\u0026rsquo;ve got a feeling that sometimes when I go home from work, I can\u0026rsquo;t get my mind out of the working status rapidly. So all the stuff that makes us energetic every day is worth purchasing.\nA latex pillow, a noise-canceling headset, they are all good for us to have a rest.\nAlso, if we think a yoga mat is good for us to immerse ourselves into meditation, we can purchase that.\nBy the way, we should notice that it doesn\u0026rsquo;t mean that we\u0026rsquo;ve formed a habit when we own the tools.\nKnowledge There\u0026rsquo;s a proverb, \u0026ldquo;Books are the windows to the world.\u0026rdquo; That\u0026rsquo;s absolutely correct.\nBut nowadays, there are some other convenient ways for us to broaden our horizons and open up our minds.\nOnline courses are convenient for us to learn new subjects, i.e., Coursera and Udemy.\nI think they\u0026rsquo;re much better than YouTube because we must concentrate on the lecture and there are homework and quizzes for us to review what we learned in the lesson. These are important for us to absorb the knowledge.\nBesides, it\u0026rsquo;s valuable to pay for a trip to a new city or new country. We\u0026rsquo;ll always meet new person and absorb new culture in a trip, that\u0026rsquo;s also a way of learning.\nTime-saving Last but not least, it\u0026rsquo;s about time-saving.\nI remembered a thought in an article, that we pay twice for each thing we purchase.\nSometimes before I buy something, I spend time looking for the lowest historical price, and then spend additional attention on the news to see if the price was reduced today. Even if I bought it at a lower price in the end, I lose the time of my attention. So in my mind, it\u0026rsquo;s worth paying a little more for the time-saving.\nThere\u0026rsquo;s another similar thing: there were a lot of pirated games and software in my country when I was a child. So I got used to finding a pirated one when a new game was released. Sometimes it takes a really long time and the download speed is very slow, which also decreases my passion. At last, the origin of satisfaction comes from finding a pirated game version instead of enjoying the story in the game. That\u0026rsquo;s not good for the developers and also for me.\nIn my mind, it\u0026rsquo;s not worth spending time on things that distract from our main goal. It seems that we spend a little more money on the surface, but it improves our concentration and helps us just enjoy today\u0026rsquo;s life.\n","date":"2025-03-26T00:00:00Z","permalink":"https://pilchark.github.io/en/p/how-to-decide-the-consumption/","title":"How to decide the consumption"},{"content":"leetcode 930: Binary Subarrays With Sum\nGiven a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\nA subarray is a contiguous part of the array.\nExample 1:\nInput: nums = [1,0,1,0,1], goal = 2 Output: 4 Explanation: The 4 subarrays are bolded and underlined below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Example 2:\nInput: nums = [0,0,0,0,0], goal = 0 Output: 15\n1. Forthright Solution Let me help you think about this differently. While recursion could be one approach, there might be a more efficient way.\nLet\u0026rsquo;s analyze your understanding:\nYou correctly identified that [1,0] and [0,1] are subarrays with sum = 1 You\u0026rsquo;re suggesting to check all possible lengths. That\u0026rsquo;s one way, but it might not be the most efficient. Let me ask you: Instead of recursion, could we use a different technique? Consider these questions:\nIf we\u0026rsquo;re looking for subarrays with a specific sum, how could we use prefix sums to help us? In the example [1,0,1], what would the prefix sums array look like? Would you like to explore this approach?\nif cur sums = goal: all_sums = prefix_sums + 1 else: all_sums = prefix_sums\nprefix sums array are [1,0] and [0,1] Let me help clarify prefix sums, as I think there might be some confusion.\nFor an array [1,0,1], the prefix sums would be:\nAfter 1st element: 1 After 2nd element: 1+0 = 1 After 3rd element: 1+0+1 = 2 So prefix sums array would be [1,1,2]\nLet\u0026rsquo;s think about this:\nIf we want to find subarrays with a specific sum, how can we use these prefix sums? For example, if our goal is 1, and at position i we have a prefix sum of 3, what prefix sum should we have seen before to make a valid subarray with sum 1? Would you like to try working out this logic with the original example [1,0,1,0,1] with goal = 2?\nthe prefix sum : [1,1,2,2,3]\nGood! You\u0026rsquo;ve correctly calculated the prefix sums for [1,0,1,0,1].\nNow let\u0026rsquo;s think about how to use these prefix sums to find subarrays with sum = 2:\nIf at position i, we have a prefix sum of say, 3, what prefix sum should we have seen before to make a subarray with sum = 2?\nFor example:\nIf current prefix sum is 3 And we want a subarray sum of 2 What previous prefix sum would we need to have seen? (Think: current_sum - goal = ?) Can you try to work out this relationship? This will help us count the valid subarrays.\nThe previous prefix sum would \u0026lt;=3\nNot exactly. Let me help you think about this more precisely:\nIf at a position we have a prefix sum of 3, and we want a subarray with sum = 2:\nCurrent prefix sum = 3 Goal sum = 2 We need to find previous prefix sums of: 3 - 2 = 1 This is because:\nIf we have a prefix sum of 3 at position i And we find a previous position j with prefix sum 1 Then the subarray from (j to i) will have sum: 3 - 1 = 2 (our goal) Let\u0026rsquo;s look at your prefix sums array [1,1,2,2,3]:\nWhen we\u0026rsquo;re at prefix sum 2, what previous prefix sum would we need to find to make a subarray of sum 2? When we\u0026rsquo;re at prefix sum 3, what previous prefix sum would we need to find to make a subarray of sum 2? Can you try answering these questions?\n2-2=0,so from the beginning to current prefix sum we nned find; 3-2=1, so there are two type of prefix we should notice,first is prefix\u0026lt;=2, second is prefix from 1 to 3. You\u0026rsquo;re getting closer, but let me help clarify:\nFor prefix sum 2:\nWe need to find previous prefix sums of: 2 - 2 = 0 So we look for positions with prefix sum 0 before this position For prefix sum 3:\nWe need to find previous prefix sums of: 3 - 2 = 1 So we look for positions with prefix sum 1 before this position The key pattern is:\nAt each position i, we look for previous positions with prefix sum = (current_prefix_sum - goal) For your prefix sums [1,1,2,2,3]:\nCan you count how many times 1 appears? When we\u0026rsquo;re at prefix sum 3, how many previous positions had prefix sum 1? When we\u0026rsquo;re at prefix sum 2, how many previous positions had prefix sum 0? Would you like to try implementing this using a dictionary/hashmap to count prefix sums?\nWhen we\u0026rsquo;re at prefix sum 3, two position has prefix sum 1 When we\u0026rsquo;re at prefix sum 2, 0 position has prefix sum 0 Good! You\u0026rsquo;re understanding it well now!\nLet\u0026rsquo;s organize what we\u0026rsquo;ve learned:\nWe can use a hashmap to keep track of the count of each prefix sum At each position, we look for (current_prefix_sum - goal) in our hashmap Would you like to try writing the code? Here\u0026rsquo;s a structure to start with:\n1 2 3 4 5 6 7 8 9 def numSubarrays(nums, goal): # Initialize variables # prefix_sum starts at 0 # create a hashmap to store count of prefix sums # iterate through nums # update prefix_sum # if (prefix_sum - goal) exists in hashmap, add to result # update hashmap with current prefix_sum Would you like to try filling in this structure?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def numSubarrays(nums, goal): # Initialize variables prefix_sum = [] sum = 0 # prefix_sum starts at 0 for i in nums: sum+=i prefix_sum.append(sum) # create a hashmap to store count of prefix sums hash_map = {} for i in prefix_sum: if i not in hash_map: hash_map[i] = 1 hash_map[i] += 1 # iterate through nums result = 0 for i in range(len(prefix_sum)-1, -1,-1): # update prefix_sum # if (prefix_sum - goal) exists in hashmap, add to result if (prefix_sum[i] - goal) in hash_map: result += hash_map[prefix_sum[i] - goal] # update hashmap with current prefix_sum return result You\u0026rsquo;re on the right track, but there are a few issues to think about:\nIn your current approach, you\u0026rsquo;re creating the prefix sums first, then counting them in a hashmap, and then checking backward. Can this cause any problems?\nWhat happens if we count all prefix sums first before checking? Could we double count some subarrays? Let\u0026rsquo;s look at the case [1,0,1,0,1] with goal = 2:\nWhat should happen when we have prefix sum = 0? Should we initialize our hashmap with anything? Let\u0026rsquo;s modify the approach to count as we go. Here\u0026rsquo;s a structure:\n1 2 3 4 5 6 7 8 9 def numSubarrays(nums, goal): curr_sum = 0 count = {0: 1} # Why do you think we initialize with {0: 1}? result = 0 for num in nums: # Update curr_sum # Check if (curr_sum - goal) exists in count # Update count with current curr_sum Can you:\nExplain why we initialize count with {0: 1}? Try completing this modified version? Yes, the first index of the arr is 1, and index start from 0, so we initialize with {0:1}\nthe modified code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def numSubarrays(nums, goal): curr_sum = 0 count = {0: 1} # Why do you think we initialize with {0: 1}? result = 0 for num in nums: # Update curr_sum curr_sum += num if curr_sum in count.keys(): count[curr_sum] += 1 else: count[curr_sum] = 1 # Check if (curr_sum - goal) exists in count if (curr_sum - goal) in count.keys(): # Update count with current curr_sum result += count[curr_sum] You\u0026rsquo;re getting closer, but there\u0026rsquo;s still a small but important error in your logic. Let\u0026rsquo;s think about it:\nWhen checking for subarrays with sum = goal, at each position with curr_sum:\nWe\u0026rsquo;re looking for previous positions where: curr_sum - goal But in your code, you\u0026rsquo;re adding count[curr_sum] to result Should it be count[curr_sum] or count[curr_sum - goal]? Let\u0026rsquo;s walk through an example with [1,0,1] and goal = 1:\nStart: count = {0: 1} After 1: curr_sum = 1, count = {0: 1, 1: 1} After 0: curr_sum = 1, count = {0: 1, 1: 2} After 1: curr_sum = 2, count = {0: 1, 1: 2, 2: 1} When curr_sum = 2, what previous prefix sum are we looking for to get a subarray of sum 1?\nWould you like to modify your code based on this?\nI noticed that, thanks.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def numSubarrays(nums, goal): curr_sum = 0 count = {0: 1} # Why do you think we initialize with {0: 1}? result = 0 for num in nums: # Update curr_sum curr_sum += num if curr_sum in count.keys(): count[curr_sum] += 1 else: count[curr_sum] = 1 # Check if (curr_sum - goal) exists in count if (curr_sum - goal) in count.keys(): # Update count with current curr_sum result += count[curr_sum - goal] There is a situation not passed. [0,0,0,0,0] should return 15\nI see the issue in your code. The problem is in how you\u0026rsquo;re updating the count dictionary and calculating the result. Let\u0026rsquo;s fix it:\nThe main issue is that you\u0026rsquo;re first updating the count for the current sum and then checking if (curr_sum - goal) exists, which means you\u0026rsquo;re counting the current subarray twice when curr_sum - goal equals curr_sum (happens when goal = 0).\nHere\u0026rsquo;s the corrected code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def numSubarraysWithSum(self, nums: List[int], goal: int) -\u0026gt; int: curr_sum = 0 count = {0: 1} # Initialize with {0: 1} to count subarrays starting from index 0 result = 0 for num in nums: # Update curr_sum curr_sum += num # Check if (curr_sum - goal) exists in count # This finds all previous positions where a subarray of sum \u0026#39;goal\u0026#39; ends at current position if (curr_sum - goal) in count: result += count[curr_sum - goal] # Update count with current curr_sum # This tracks the number of times we\u0026#39;ve seen each prefix sum count[curr_sum] = count.get(curr_sum, 0) + 1 return result The key changes are:\nFirst check if (curr_sum - goal) exists before updating the count Use count.get(curr_sum, 0) + 1 for cleaner code instead of checking if key exists Removed redundant .keys() calls when checking dictionary keys This approach correctly counts the number of subarrays with sum equal to the goal, including when the goal is 0 (as in the [0,0,0,0,0] test case).\nFor the [0,0,0,0,0] example with goal=0:\nWe find all subarrays that have a sum of 0 This includes subarrays of all possible lengths (1, 2, 3, 4, 5) Total: 5 + 4 + 3 + 2 + 1 = 15 subarrays final:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def numSubarraysWithSum(self, nums: List[int], goal: int) -\u0026gt; int: curr_sum = 0 count = {0: 1} # Initialize with {0: 1} to count subarrays starting from index 0 result = 0 for num in nums: # Update curr_sum curr_sum += num # Check if (curr_sum - goal) exists in count # This finds all previous positions where a subarray of sum \u0026#39;goal\u0026#39; ends at current position if (curr_sum - goal) in count: result += count[curr_sum - goal] # Update count with current curr_sum # This tracks the number of times we\u0026#39;ve seen each prefix sum count[curr_sum] = count.get(curr_sum, 0) + 1 return result ","date":"2025-03-24T21:46:00Z","permalink":"https://pilchark.github.io/en/p/binary-subarrays-with-sum/","title":"Binary Subarrays With Sum"},{"content":"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.\n1. Forthright Solution I\u0026rsquo;ll help guide you through solving this problem! Since we need O(log n) runtime complexity, this might suggest a particular approach. What algorithm do you think would be most appropriate for searching in a sorted array with logarithmic time complexity?\nLet\u0026rsquo;s break this down step by step. First, can you tell me what algorithm you think might be suitable here?\nThe Binary search method.\nThat\u0026rsquo;s exactly right! Binary search is perfect here since we have a sorted array and need O(log n) complexity.\nBefore we start coding, let\u0026rsquo;s think about how binary search would work in this case. What makes this problem slightly different from a regular binary search where we\u0026rsquo;re just looking for a target?\nCan you describe what should happen if the target is NOT found in the array? How would we determine where it should be inserted?\nThe difference:\nBinary search: Find the index, if not return false. This problem: Find the index,if not, compared to the value in final loop, if the key is smaller, return p-1, if is larger, return p+1. I see your thinking, but let me ask you a question about your approach. Let\u0026rsquo;s consider this example: nums = [1,3,5,6] and target = 2\nIf we do a binary search and the target isn\u0026rsquo;t found, do we really need to check if the key is smaller/larger and do p-1 or p+1?\nThink about where our left pointer ends up in binary search when an element isn\u0026rsquo;t found. Could we use this information directly? What does the position of the left pointer tell us about where the element should be inserted?\nI get your point, maybe we don\u0026rsquo;t compare, just return the final left point +1 when the loop ended?\nYou\u0026rsquo;re getting closer! But let\u0026rsquo;s think about this carefully.\nWhen the binary search loop ends, why would we need to return left +1? Could we just return left?\nLet\u0026rsquo;s look at a specific example: nums = [1,3,5,6], target = 2\nCan you walk me through what happens to the left and right pointers during the binary search, and where they end up? This will help us understand exactly what we should return.\nhere is the walk through\nleft=0, right=3,compare 2 to numd[(right-left)//2] 2 is smaller=\u0026gt; right-= (right-left)//2 left=0, right=2,compare 2 to nums[(right-left)//2] 2 is smaller ==\u0026gt; right-= (right-left)//2 left=0, right=1,compare 2 to nums[(right-left)//2],2 is bigger,left+=(right-left)//2 final left=1 Excellent walkthrough! Now let\u0026rsquo;s analyze what we discovered:\nIn your example with target = 2, the left pointer ended at 1, which is exactly where 2 should be inserted between 1 and 3.\nSo what does this tell us about our original question - do we need to add 1 to left? Looking at your walkthrough, it seems like we can just return \u0026rsquo;left\u0026rsquo; directly.\nWould you like to try writing the code for this solution? Remember we need:\nBinary search loop Return logic when we find the target Return logic when we don\u0026rsquo;t find the target Can you give it a try?\n1 2 3 4 5 6 7 8 9 10 11 12 def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: n = len(nums) p,q = 0,n-1 while p\u0026lt;q: m = (q-p)//2 if target \u0026lt; m: q-=m elif target \u0026gt; m: p+=m else: return m return p+1 Let\u0026rsquo;s analyze your code. There are a few issues we should think about:\nIn your code, you\u0026rsquo;re comparing target with \u0026rsquo;m\u0026rsquo; (which is just the middle index). Should we be comparing target with the middle index, or the value at the middle index (nums[m])?\nYour calculation of the middle point \u0026rsquo;m = (q-p)//2\u0026rsquo; might not give us the actual middle. What\u0026rsquo;s the standard way to calculate the middle point between two indices?\nThe condition \u0026lsquo;p \u0026lt; q\u0026rsquo; might cause us to miss checking some elements. Should it be \u0026lsquo;p \u0026lt;= q\u0026rsquo;?\nLet\u0026rsquo;s test your code with a simple example: nums = [1,3,5,6], target = 5\nCan you walk through how your current code would handle this case? Can you spot any issues and suggest improvements?\nsure, I\u0026rsquo;ll fix that.\n1 2 3 4 5 6 7 8 9 10 11 12 def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: n = len(nums) p,q = 0,n-1 while p\u0026lt;=q: # avoid miss checking,p \u0026lt;=q m = p+ (q-p)//2 # the middle index if target \u0026lt; nums[m]: q-=m elif target \u0026gt; nums[m]: p+=m else: return m return p+1 You\u0026rsquo;re getting closer, but there are still a few issues to fix. Let\u0026rsquo;s think about your binary search updates:\nWhen you do q-=m and p+=m, you\u0026rsquo;re subtracting/adding the middle index. Is this correct? What should happen when target is smaller than nums[m]? What should happen when target is larger than nums[m]? Let\u0026rsquo;s test with an example: nums = [1,3,5,6], target = 2\nFirst iteration:\np = 0, q = 3 m = 0 + (3-0)//2 = 1 nums[m] = 3 target(2) \u0026lt; numsm Your code does: q -= m (q = 3-1 = 2) Is this the correct way to update the search space? How should we modify the pointers to properly narrow down our search?\nI noticed that, thanks\n1 2 3 4 5 6 7 8 9 10 11 12 def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: n = len(nums) p,q = 0,n-1 while p\u0026lt;=q: # avoid miss checking,p \u0026lt;=q m = p+ (q-p)//2 # the middle index if target \u0026lt; nums[m]: q=m elif target \u0026gt; nums[m]: p=m else: return m return p+1 You\u0026rsquo;re very close! But there\u0026rsquo;s still one small but important issue that could cause an infinite loop. Let\u0026rsquo;s analyze:\nWhen you update the pointers:\nIf target \u0026lt; nums[m], you do q = m If target \u0026gt; nums[m], you do p = m Consider this case: nums = [1,3], target = 2\nFirst iteration: p = 0, q = 1, m = 0 nums[m] = 1 target(2) \u0026gt; numsm p = m (p stays at 0) Do you see what might happen here? How can we modify the pointer updates to ensure the search space actually shrinks each time?\nI got that, maybe the update for q\u0026amp;p should change to m+1 and m-1, here is code\n1 2 3 4 5 6 7 8 9 10 11 12 def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: n = len(nums) p,q = 0,n-1 while p\u0026lt;=q: # avoid miss checking,p \u0026lt;=q m = p+ (q-p)//2 # the middle index if target \u0026lt; nums[m]: q=m-1 elif target \u0026gt; nums[m]: p=m+1 else: return m return p+1 Perfect! Let\u0026rsquo;s verify why this works better:\nWhen target \u0026lt; nums[m], we move q to m-1 because we know target can\u0026rsquo;t be at m or after it When target \u0026gt; nums[m], we move p to m+1 because we know target can\u0026rsquo;t be at m or before it The search space reduces by at least one element in each iteration When p and q cross, p will end up at the correct insertion point Let\u0026rsquo;s verify with a few test cases:\nnums = [1,3,5,6], target = 5 (target exists) nums = [1,3,5,6], target = 2 (target doesn\u0026rsquo;t exist) nums = [1], target = 0 (target should go at beginning) Would you like to walk through any of these test cases to verify the solution works correctly? This would help ensure you fully understand how the algorithm handles different scenarios.\nI noticed taht if the target was not found ,no need return p+1 finally,the p already equal m+1 in each loop. here is the final\n1 2 3 4 5 6 7 8 9 10 11 12 def searchInsert(nums: List[int], target: int) -\u0026gt; int: n = len(nums) p,q = 0,n-1 while p\u0026lt;=q: # avoid miss checking,p \u0026lt;=q m = p+ (q-p)//2 # the middle index if target \u0026lt; nums[m]: q=m-1 elif target \u0026gt; nums[m]: p=m+1 else: return m return p # not p+1 since the final step always p=m+1 2. Research Tips for Binary Search sorted : Ensure the array is sorted. Edge Cases: Consider edge cases such as an empty array, an array with one element, or the target value being at the beginning or end of the array. Iterative vs. Recursive: Binary search can be implemented iteratively or recursively. Choose the one that fits your needs. Iterative is generally preferred for its simplicity and to avoid potential stack overflow issues with recursion. Indices Management: Be careful with the calculation of the middle index to avoid overflow. Return Values: Decide what to return if the target is not found. Typically, you return -1 or None. Performance: Binary search has a time complexity of O(log n), making it very efficient for large datasets. Iterative Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def binary_search_iterative(arr, target): left, right = 0, len(arr) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] \u0026lt; target: left = mid + 1 else: right = mid - 1 return -1 # Target not found # Example usage arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 result = binary_search_iterative(arr, target) print(f\u0026#34;Element found at index: {result}\u0026#34;) Recursive Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binary_search_recursive(arr, target, left, right): if left \u0026gt; right: return -1 # Target not found mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] \u0026lt; target: return binary_search_recursive(arr, target, mid + 1, right) else: return binary_search_recursive(arr, target, left, mid - 1) # Example usage arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 result = binary_search_recursive(arr, target, 0, len(arr) - 1) print(f\u0026#34;Element found at index: {result}\u0026#34;) ","date":"2025-03-20T16:46:00Z","permalink":"https://pilchark.github.io/en/p/search-insert-position/","title":"Search Insert Position"},{"content":"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n1. Forthright Solution use a simple example:\nhaystack = \u0026ldquo;hello\u0026rdquo;\nneedle = \u0026ldquo;ll\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: p_stack = 0 p_ndl = 0 start = 0 for i in range(len(haystack)): if haystack[i] == needle[p_ndl]: p_stack += 1 p_ndl += 1 else: start = i if p_ndl == len(needle): return start else: return -1 assistant Let\u0026rsquo;s analyze your approach. I notice a few things we should think about:\nIn your current code, when characters don\u0026rsquo;t match (else case), you\u0026rsquo;re setting start = i, but what about p_ndl? Should it reset?\nLet\u0026rsquo;s test this with a simple example: haystack = \u0026ldquo;hello\u0026rdquo; needle = \u0026ldquo;ll\u0026rdquo;\nCan you walk me through how your pointers would move in this case?\nThere seems to be an issue with the start variable. When we find a match, we need to return the position where the match began, not where it ended. How might we modify this? Would you like to try adjusting your code to address these points?\nSure ,here is the walk through:\n\u0026ldquo;h\u0026rdquo;: not match,start change to 1,p_ndl = 0 \u0026ldquo;e\u0026rdquo;: not match,start change to 2,p_ndl = 0 \u0026ldquo;l\u0026rdquo;: matched,start still 2,p_ndl = 1 \u0026ldquo;l\u0026rdquo;: matched,start still 2,p_ndl = 2, return 2 this is code update:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: p_ndl = 0 start = 0 for i in range(len(haystack)): if haystack[i] == needle[p_ndl]: p_ndl += 1 else: p_ndl = 0 start = i+1 if p_ndl == len(needle): return start else: return -1 Let\u0026rsquo;s test this updated code with a few cases. I notice something that might need attention:\nWhen we have a mismatch, you set start = i+1, but should we always move the start position forward? Let\u0026rsquo;s test with this example: haystack = \u0026ldquo;mississippi\u0026rdquo; needle = \u0026ldquo;issi\u0026rdquo;\nCan you walk through how your current code would handle this case? Pay special attention to:\nWhat happens when we find the first \u0026lsquo;i\u0026rsquo;? If we encounter a mismatch after matching some characters, should we really jump to i+1, or should we try matching from an earlier position? Would you like to try tracing through this example to see if you spot any potential issues?\nI can see the issue not, when haystack = \u0026ldquo;mississippi\u0026rdquo; needle = \u0026ldquo;issip\u0026rdquo;, current script will return -1. So if there is a mismatch,I shouldn\u0026rsquo;d jump to i+1,I should try match from an earlier position(if it match the 1st character in needle).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: start = 0 p_ndl = 0 for i in range(len(haystack)): if haystack[i] != needle[p_ndl]: start += 1 else: for j in range(len(needle)): if needle[j] == haystack[j+start]: continue else: start += 1 break else: return start else: return -1 I see you\u0026rsquo;re trying to modify the approach by adding a nested loop to check for matches. Let\u0026rsquo;s analyze this new approach:\nWhen you find a potential match, you\u0026rsquo;re using a nested loop with j+start. Could this potentially cause any index out of range issues? When might this happen?\nLet\u0026rsquo;s walk through your code with a simple example: haystack = \u0026ldquo;hello\u0026rdquo; needle = \u0026ldquo;ll\u0026rdquo;\nCould you trace:\nHow does start change? What happens when we find the first \u0026rsquo;l'? Is the nested loop handling the matching process efficiently? There might be a simpler way to handle this. Instead of using a nested loop, could we maintain our two-pointer approach but with better handling of mismatches? Would you like to try refining your solution considering these points?\nI see there\u0026rsquo;s a potential problem when needle is longer than haystack. here\u0026rsquo;s the udpate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: start = 0 p_ndl = 0 for i in range(len(haystack)): if haystack[i] != needle[p_ndl]: start += 1 else: for j in range(len(needle)): if j+start \u0026gt; len(haystack)-1: return -1 if needle[j] == haystack[j+start]: continue else: start += 1 break else: return start else: return -1 Good catch on handling the index out of range issue! However, there are still some aspects of the solution that could be improved:\nLet\u0026rsquo;s test with this example: haystack = \u0026ldquo;mississippi\u0026rdquo; needle = \u0026ldquo;issi\u0026rdquo; When you increment start by 1 each time there\u0026rsquo;s a mismatch, you might skip potential matches. For instance:\nIf you find \u0026lsquo;i\u0026rsquo; but the subsequent characters don\u0026rsquo;t match Should you really move start by 1, or should you try matching from some other position? Also, consider the efficiency: Right now, for each character match, you\u0026rsquo;re checking the entire needle string again Could we keep track of how many characters have matched so far instead? Would you like to try modifying your approach to handle these cases more efficiently? Think about how you could use your original two-pointer approach but with better handling of mismatches.\n2. Research 3 way for Pattern-Matching Algorithms\nBrute Force The Knuth-Morris-Pratt Algorithm The Boyer-Moore Algorithm brute force 1 2 3 4 5 6 7 8 9 def find brute(T, P): n, m = len(T), len(P) # introduce convenient notations for i in range(n−m+1): # try every potential starting index within T k = 0 # an index into pattern P while k \u0026lt; m and T[i + k] == P[k]: # kth character of P matches k += 1 if k == m: # if we reached the end of pattern, return i # substring T[i:i+m] matches P return −1 # failed to find a match starting with any i worst case : O(nm)\nThe Knuth-Morris-Pratt Algorithm 1. the failture function concept: the failure function f(k) is defined as the length of the longest prefix of P that is a suffix of P[1:k+1]\nnote that we did not include P[0] here, since we will shift at least one unit purpose: it tells us how many of the immediately preceding characters can be reused to restart the pattern.\nk 0 1 2 3 4 5 6 7 8 9 10 11 P[k] a m a l g a m a t i o n f(k) 0 0 1 0 0 1 2 3 0 0 0 0 implement:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def compute_kmp_fail(P): m = len(P) fail = [0] * m j = 1 k = 0 while j \u0026lt; m: if P[j] == P[k]: fail[j] = k + 1 j += 1 k += 1 elif k \u0026gt; 0: k = fail[k - 1] else: j += 1 return fail 2. the solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def find_kmp(T, P): \u0026#34;\u0026#34;\u0026#34;Return the lowest index of T at which substring P begins (or else -1).\u0026#34;\u0026#34;\u0026#34; n, m = len(T), len(P) if m == 0: return 0 fail = compute_kmp_fail(P) j, k = 0, 0 # index into text, pattern while j \u0026lt; n: if T[j] == P[k]: if k == m - 1: return j - m + 1 j += 1 k += 1 elif k \u0026gt; 0: k = fail[k - 1] # reuse suffix of P[0:k] else: j += 1 return -1 time performance O(n + m)\n3. The Boyer-Moore Algorithm Align the String with the pattern head and compare them starting at the end. eg. string: \u0026ldquo;HERE IS A SIMPLE EXAMPLE\u0026rdquo;, pattern: \u0026ldquo;EXAMPLE\u0026rdquo;.\nDuringthetestingofapossibleplacementofPwithin T, a mismatch of text character T[i]=c with the corresponding pattern char- acter P[k] is handled as follows. If c is not contained anywhere in P, then shift P completely past T[i] (for it cannot match any character in P). Other- wise, shift P until an occurrence of character c in P gets aligned with T[i].\nreference：\nData Structures and Algorithms in Python,by Michael T. Goodrich (Author), Roberto Tamassia (Author) https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html ","date":"2025-03-19T14:33:00Z","permalink":"https://pilchark.github.io/en/p/find-the-index-of-the-first-occurrence-in-a-string/","title":"find-the-index-of-the-first-occurrence-in-a-string"},{"content":"1. Safety First Personal safety should always be your top priority, no matter where you travel. If you\u0026rsquo;re visiting a country where firearms are legal, research ahead to avoid dangerous areas, slums, or conflict zones.\nSafety isn\u0026rsquo;t just about avoiding crime. When traveling to places with different climates from your home, be mindful of health risks like heatstroke or extreme cold. If you\u0026rsquo;re planning activities like hiking away from city centers, ensure your phone is fully charged and consider carrying a backup phone for emergencies. Having a way to contact emergency services (like 911) could be crucial.\n2. Explore Off the Beaten Path When people think of major world cities, they often focus on famous landmarks - London\u0026rsquo;s Big Ben, New York\u0026rsquo;s Statue of Liberty, or Paris\u0026rsquo;s Eiffel Tower. While these are impressive, they don\u0026rsquo;t tell the whole story. To truly understand a city\u0026rsquo;s lifestyle and hidden character, venture into local markets for breakfast, observe the daily routines of street cleaners, chat with small shop owners, or watch elderly residents in parks. These authentic experiences reveal the city\u0026rsquo;s true spirit in ways that tourist attractions can\u0026rsquo;t.\n3. Focus on One Main Goal Many office workers, with their limited vacation time, try to pack too many attractions into their itinerary. In China, these rushed tourists are jokingly called \u0026ldquo;Navy SEAL Travelers.\u0026rdquo; This approach often leads to anxiety about completing a lengthy to-do list rather than enjoying the experience.\nInstead, set one primary goal for your trip and focus on achieving it. Consider everything else a bonus. This approach helps you fully appreciate your chosen experience without the stress of rushing through multiple attractions. Once you\u0026rsquo;ve accomplished your main goal, you can relax and explore other sites if time permits.\n","date":"2025-02-28T00:00:00Z","permalink":"https://pilchark.github.io/en/p/how-to-travel-to-a-new-city/","title":"how to travel to a new city"},{"content":"What is Fragment Addiction? A compulsive obsession with an activity or behavior that is so overwhelming that it disrupts one\u0026rsquo;s normal routine and daily schedule.\nWhen someone withdraws from the activity suddenly, they experience negative emotions, feelings, and even anxiety.\nHow fragment Addiction Develops Intrinsically Work-related stress or feeling the need to be productive during short breaks leads to seeking stimulation for dopamine release in the brain.\nExternal Through algorithmic recommendations of short videos that target personal interests and preferences, along with incentives like cash-out bonuses.\nHow to overcome Recognition Accept yourself - gaming is okay, and taking time to rest is also okay. Don\u0026rsquo;t pressure yourself to overcome the addiction immediately. Instead, analyze how much time you spend on these activities and consider if that aligns with your goals.\nTransformation Create daily plans. One effective method I\u0026rsquo;ve seen involves dividing the day into time blocks and tracking completed tasks. Try new activities and embrace challenges - they can energize you. Step out of your comfort zone, even if it\u0026rsquo;s just one small step at a time.\n","date":"2025-02-17T00:00:00Z","permalink":"https://pilchark.github.io/en/p/how-to-deal-with-fragmented-addiction/","title":"how to deal with fragmented addiction"},{"content":"1. What is an involution(inner scroll) While in the working circle, students in schools study hard from each other and strive to surpass the majority of people around them.\n2. Why it was formed? The working environment is highly competitive, few job posts with a large amount of potential competitors.\n3. Conception In the current context of fierce competition in society, enterprises are cutting costs and there are large-scale corporate layoffs. ordinary workers can relieve anxiety and maintain stable income. The phenomenon of doing it to survive. Citing the nature of domestic work, he was exhausted before retirement, but he felt disappointed after retirement. The 70-year-old retired man in Japan still worked hard. Here, we don\u0026rsquo;t need to compare the differences between political system, we just say that, moderate volumes are actually beneficial to the growth of individuals in society, However, it should not exceed the limits allowed by the individual\u0026rsquo;s physical and mental health.\n4. how to deal with it Don\u0026rsquo;t \u0026ldquo;lie flat\u0026rdquo;, The essence of human beings is that they need input and labor to get satisfaction. Maintain a state of learning, be more receptive to new things, and take the initiative in potential future environments.\n","date":"2025-02-10T00:00:00Z","permalink":"https://pilchark.github.io/en/p/involution-is-a-phenomenon/","title":"Involution is a phenomenon"},{"content":"Short videos bring an elevated emotional threshold to the modern man The rapid development of science and technology is always a double-edged sword. While enjoying the convenience it brings, we also have to be wary of the \u0026rsquo;erosion\u0026rsquo; of us. We have entered an era of short videos, and while the density of information access has been greatly increased, it seems that we have lost our awareness of the most primitive and subtle human emotions. The fast-paced changes of short videos can sway us visually, but they can\u0026rsquo;t bring us rapid emotional ups and downs. Our brains are lagging behind in emotional changes, but this is a precious asset of human beings.\nBut the film appeared in the little girl, her body red, that is, in the concentration camps, corpses everywhere in the Jewish city brought a touch of vitality, an uncontaminated by the war vitality, but at the same time this red so dim, seemingly seemingly nothing, at any time will be engulfed, like the color of blood.\n","date":"2025-01-18T00:00:00Z","permalink":"https://pilchark.github.io/en/p/short-videos-and-movies/","title":"About Short Video and Movie Random Thoughts"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://pilchark.github.io/en/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]